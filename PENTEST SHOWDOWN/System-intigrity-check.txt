-------------------------------------------------------------------------
CTF CHALLENGE WRITEUP: SYSTEM INTEGRITY CHECK
-------------------------------------------------------------------------
Category:   Reverse Engineering
Difficulty: Easy/Medium

DESCRIPTION
-------------------------------------------------------------------------
"We recovered this binary from a secure server. It seems to handle system 
authorization. The logs are corrupted and full of random errors. Watch 
out for decoys."

Attached Files:
- sys_check.exe (The challenge binary)
- player.txt (The hints)

-------------------------------------------------------------------------
SOLUTION WALKTHROUGH
-------------------------------------------------------------------------

1. INITIAL ANALYSIS
   We start by running the binary. It asks for an "authorization token."
   If we enter a wrong password (e.g., "test"), a Windows Popup appears 
   with a random error message like "Critical Failure" or "Intruder detected." 
   These messages change every time we run it, confirming the hint that the
   errors are just noise to distract us.

2. STATIC ANALYSIS (THE "STRINGS" TRAP)
   Running the 'strings' command on the binary reveals a tempting line:
   
       FAKE{try_again}
   
   However, the challenge description warned us about a "decoy." If we 
   submit this flag, the program rejects it. This is a rabbit hole designed
   to catch players who don't look deeper.

3. DECOMPILATION (THE REAL LOGIC)
   Opening the binary in a decompiler (like Ghidra or IDA) reveals the truth.
   Inside the 'main' function, there are two distinct blocks of code 
   constructing strings character-by-character (Stack Strings).

   Block A ( The Decoy ):
   Constructs "FAKE{try_again}" using simple assignments. This variable is 
   never actually compared to our input; it just sits there.

   Block B ( The Real Flag ):
   A second block constructs a string using arithmetic operations to hide 
   the values from simple search tools:
   
       config[0] = 35 + 32;   // (67 -> 'C')
       config[1] = 100 - 16;  // (84 -> 'T')
       config[2] = 35 * 2;    // (70 -> 'F')
       ... and so on.

   The code then compares our input specifically against this second 
   constructed string.

4. DECODING THE FLAG
   By converting the calculated ASCII values to text, we get:
   
   - 0x43 (67)  -> C
   - 0x54 (84)  -> T
   - 0x46 (70)  -> F
   - 0x7B (123) -> {
   - 0x6E (110) -> n
   - 0x30 (48)  -> 0
   - 0x5F (95)  -> _
   - 0x6E (110) -> n
   - 0x34 (52)  -> 4
   - 0x6D (109) -> m
   - 0x33 (51)  -> 3
   - 0x73 (115) -> s
   - 0x7D (125) -> }

-------------------------------------------------------------------------
FINAL FLAG
-------------------------------------------------------------------------
CTF{n0_n4m3s}