
VM Auth â€” Official Post-Challenge Write-Up
========================================

Category: Reverse Engineering
Difficulty: Medium+
File Provided: vm_auth (Linux ELF binary)
Platform: Linux x86-64
Flag: FLAG{STACK_VM_LINUX}

--------------------------------------------------
1. What the Player Receives
--------------------------------------------------

The challenge provides ONLY ONE FILE:

    vm_auth

This file is:
- A Linux ELF 64-bit executable
- Stripped (no symbols)
- Dynamically linked
- The only artifact needed to solve the challenge

No source code, no hints, no scripts are provided.

--------------------------------------------------
2. Identify the Binary
--------------------------------------------------

Command:
    file vm_auth

Output:
    ELF 64-bit LSB executable, x86-64, stripped

This confirms:
- Reverse engineering is required
- Static and dynamic analysis will be used

--------------------------------------------------
3. Running the Binary
--------------------------------------------------

Command:
    ./vm_auth

Output:
    Enter flag:

The program expects user input and validates it as a flag.

--------------------------------------------------
4. Length Check
--------------------------------------------------

Input:
    test

Output:
    Wrong length

Conclusion:
- The flag length is fixed
- Length is validated before deeper logic
- Brute forcing random lengths is useless

--------------------------------------------------
5. Correct Length but Wrong Input
--------------------------------------------------

Input:
    AAAAAAAAAAAAAAAAAAAA

Output:
    [VM] PUSH_IDX
    [VM] XOR
    [VM] ADD
    [VM] ROL
    [VM] CMP
    ACCESS DENIED

Important observation:
- The program prints VM instruction names
- This strongly indicates a custom virtual machine

--------------------------------------------------
6. Key Observation: Virtual Machine
--------------------------------------------------

The output shows instruction-like messages:
- PUSH_IDX
- XOR
- ADD
- ROL
- CMP

This means:
- The flag is validated by a VM
- The VM executes bytecode
- Each instruction transforms input data

--------------------------------------------------
7. What the Player Must Find
--------------------------------------------------

The player must discover:
1. The VM instruction set
2. What each instruction does
3. Where the VM bytecode is stored
4. How the bytecode is decrypted
5. How each character is validated
6. How to reverse the logic

--------------------------------------------------
8. .rodata Section Analysis
--------------------------------------------------

In the .rodata section, we find strings such as:

    "Enter flag:"
    "Wrong length"
    "[VM] PUSH_IDX"
    "[VM] XOR"
    "[VM] ADD"
    "[VM] ROL"
    "[VM] CMP"
    "ACCESS DENIED"
    "ACCESS GRANTED"

These strings confirm:
- A VM exists
- Instruction names are intentionally leaked
- Success and failure states are clear

--------------------------------------------------
9. VM Instruction Set
--------------------------------------------------

Recovered instruction meanings:

PUSH_IDX : Push flag[index] onto the stack
XOR      : XOR top of stack with a key
ADD      : Add a constant to top of stack
ROL      : Rotate bits left
CMP      : Compare value with expected constant

--------------------------------------------------
10. Encrypted Bytecode
--------------------------------------------------

The VM bytecode is not stored in plaintext.
Each byte is decrypted at runtime using:

    real_byte = encrypted_byte XOR (0xA5 + program_counter)

This prevents trivial static extraction.

--------------------------------------------------
11. VM Execution Pattern
--------------------------------------------------

The same instruction pattern repeats:

    PUSH_IDX i
    XOR key
    ADD value
    ROL rotation
    CMP expected

Each block validates ONE character of the flag.

--------------------------------------------------
12. Validation Logic (Forward)
--------------------------------------------------

For each character flag[i]:

    v = flag[i]
    v = v XOR key
    v = v + add_value
    v = ROL(v, rotation)

    if v != expected:
        ACCESS DENIED

If all comparisons pass:
    ACCESS GRANTED

--------------------------------------------------
13. Key Insight: Independent Characters
--------------------------------------------------

Each character is checked independently.
This means:
- No brute force needed
- Each character can be solved on its own

--------------------------------------------------
14. Reversing the Logic
--------------------------------------------------

To recover the original character, reverse operations:

    v = expected
    v = ROR(v, rotation)
    v = v - add_value
    v = v XOR key

This yields the original ASCII value.

--------------------------------------------------
15. Example: Recovering One Character
--------------------------------------------------

Assume extracted values:

    index      = 0
    xor_key    = 0x22
    add_value  = 7
    rotation   = 3
    expected   = 0x9A

Step-by-step:

    v = 0x9A
    v = ROR(0x9A, 3) = 0x53
    v = 0x53 - 7     = 0x4C
    v = 0x4C XOR 0x22 = 0x6E

ASCII:
    0x6E = 'n'

So:
    flag[0] = 'n'

--------------------------------------------------
16. Constructing the Full Flag
--------------------------------------------------

Repeat the same reversal for every VM block.
Each block gives exactly one character.

Because PUSH_IDX specifies the index,
characters are already in correct order.

Recovered characters:

    F L A G { S T A C K _ V M _ L I N U X }

--------------------------------------------------
17. Final Flag
--------------------------------------------------

FLAG{STACK_VM_LINUX}

--------------------------------------------------
18. Final Verification
--------------------------------------------------

Input:
    FLAG{STACK_VM_LINUX}

Output:
    ACCESS GRANTED

--------------------------------------------------
19. Why This Challenge Is Medium+
--------------------------------------------------

- Custom virtual machine
- Encrypted bytecode
- Stack-based execution
- Requires emulation
- No brute force possible
- Single binary provided

--------------------------------------------------
20. Key Takeaway
--------------------------------------------------

When a binary prints VM-like instructions:
- Stop guessing input
- Reverse the VM
- Invert the math
- Reconstruct the flag deterministically

End of write-up.
