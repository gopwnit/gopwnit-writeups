============================================================
Official Write-Up – Reverse Engineering (Hard)
============================================================

Challenge Type : Reverse Engineering
Difficulty     : Hard
Obfuscation    : movfuscator
Input Type     : Binary (stdin)
Output         : Correct! / Wrong!
Flag Format    : CTF{...}

------------------------------------------------------------
Overview
------------------------------------------------------------

The challenge provides a heavily obfuscated binary that validates
a fixed-length input from stdin. The binary never prints the flag
and provides no partial feedback. The goal is to reverse the
validation logic, recover the correct binary input, and finally
decode the real human-readable flag offline.

The challenge is intentionally designed to:
- Hide logic using movfuscator
- Prevent string-based extraction
- Require data extraction + algorithm inversion
- Require binary (non-text) input
- Force offline decoding of the final flag

------------------------------------------------------------
Phase 0 – Initial Black-Box Testing
------------------------------------------------------------

Tool Used:
- Linux shell

Action:
Run the binary with random input.

    ./chall
    AAAA

Observation:
- Output is always either "Correct!" or "Wrong!"
- No crash
- No delay
- No partial feedback

Conclusion:
- Deterministic checker
- Fixed-length validation
- Likely byte-by-byte comparison
- No oracle attacks possible

------------------------------------------------------------
Phase 1 – Basic Static Reconnaissance
------------------------------------------------------------

Tool Used:
- strings

Action:

    strings chall

Observation:
- Only visible strings:
    "Correct!"
    "Wrong!"
- No CTF{...}
- No readable secrets

Conclusion:
- Flag is not stored as plaintext
- No trivial extraction
- Must be encoded or computed

------------------------------------------------------------
Phase 2 – Binary Structure and Obfuscation Detection
------------------------------------------------------------

Tools Used:
- readelf
- Ghidra

Action:
Inspect ELF sections.

    readelf -S chall

Observation:
- Large .text section
- Disassembly contains almost only MOV instructions
- Arithmetic and control flow are heavily flattened

Conclusion:
- Binary is movfuscated
- Static reading of logic is intentionally difficult
- Data extraction will be easier than code analysis

------------------------------------------------------------
Phase 3 – Locating the Validation Loop
------------------------------------------------------------

Tool Used:
- Ghidra (Decompiler + Listing View)

Action:
Navigate to main() and inspect control flow.

Observation:
- A loop structure is still visible despite movfuscation
- Input buffer accessed with an index
- Loop counter increments linearly
- Loop executes exactly 36 iterations

Conclusion:
- Input length is exactly 36 bytes
- Validation is per-byte
- There must exist a 36-byte reference table

------------------------------------------------------------
Phase 4 – Extracting the Constant Table (seeds[])
------------------------------------------------------------

Tools Used:
- Ghidra (Listing View, Data View)
- Optional: gdb

Step 4.1 – Identifying Constant Memory Access

Inside the validation loop, instructions appear in the form:

    mov al, byte ptr [rip + offset]

Key observations:
- The memory address changes every iteration
- Access pattern is sequential
- Loaded byte is used in comparison logic

This indicates a static byte array.

Step 4.2 – Following the Reference

In Ghidra:
- Click the referenced address
- Jump to memory location

Observation:
- A contiguous block of high-entropy bytes
- Exactly 36 bytes long
- Not executable code

Step 4.3 – Defining Structured Data

In Ghidra:
- Select the byte range
- Right-click → Data → Define Array
- Type: uint8_t
- Length: 36

Resulting data:

    0xe4, 0xf3, 0xe1, 0xdc, 0xea, 0x97, 0xf1, 0xf8,
    0x96, 0xd4, 0xf8, 0xf3, 0xd2, 0xd5, 0x96, 0xc9,
    0xc0, 0xf8, 0xe4, 0x97, 0xca, 0xd7, 0xcb, 0x94,
    0xd3, 0x94, 0xf8, 0xe6, 0xc9, 0xc3, 0xf8, 0xea,
    0x97, 0xf5, 0x94, 0xda

Conclusion:
- This is the target output table
- Commonly named seeds[]
- Key to solving the challenge

------------------------------------------------------------
Phase 5 – Reconstructing the Transformation Logic
------------------------------------------------------------

Tools Used:
- Ghidra (Decompiler)
- Manual data-flow analysis

Approach:
Ignore movfuscator noise. Track how a single input byte flows
through registers and affects the accumulator.

Observations:
1. Input byte is XORed with constant 0xA7
2. Result undergoes an 8-bit rotate-left by 5
3. Constant 0x37 is added
4. Result is XORed with seeds[i]
5. XOR result is ORed into a global accumulator

Reconstructed logic:

    t = input[i] ^ 0xA7;
    t = rol8(t, 5);
    t = t + 0x37;
    acc |= (t ^ seeds[i]);

Properties:
- Pure 8-bit arithmetic
- No early exit
- Constant-time comparison
- All operations are invertible

------------------------------------------------------------
Phase 6 – Inverting the Algorithm
------------------------------------------------------------

Goal:
Recover input[i] given seeds[i].

Each operation is invertible:

    +0x37  →  -0x37
    rol8   →  ror8
    ^0xA7  →  ^0xA7

Reverse order is critical.

Forward order:
    input → XOR → ROL → ADD → compare

Reverse order:
    seeds → SUB → ROR → XOR → input

Inverse logic:

    t = seeds[i]
    t = t - 0x37
    t = ror8(t, 5)
    input[i] = t ^ 0xA7

------------------------------------------------------------
Phase 7 – Solver Implementation
------------------------------------------------------------

Tool Used:
- Python

Solver code:

    def ror8(x, r):
        return ((x >> r) | (x << (8 - r))) & 0xFF

    seeds = [ ... 36 bytes ... ]

    flag = bytearray()

    for s in seeds:
        t = (s - 0x37) & 0xFF
        t = ror8(t, 5)
        t = t ^ 0xA7
        flag.append(t)

    with open("flag.bin", "wb") as f:
        f.write(flag)

------------------------------------------------------------
Phase 8 – Verifying the Binary Input
------------------------------------------------------------

Tool Used:
- Shell redirection

    ./chall < flag.bin

Output:

    Correct!

Conclusion:
- flag.bin is the exact binary input expected by the checker

------------------------------------------------------------
Phase 9 – Recovering the Real Text Flag
------------------------------------------------------------

Observation:
seeds[] is XOR-encoded with 0xA7.

Decode:

    real_flag = bytes(b ^ 0xA7 for b in seeds)
    print(real_flag.decode())

Result:

    CTF{M0V_1s_Tur1ng_C0mpl3t3_And_M0R3}

------------------------------------------------------------
Final Flag
------------------------------------------------------------

CTF{M0V_1s_Tur1ng_C0mpl3t3_And_M0R3}

------------------------------------------------------------
Why This Challenge Is Hard but Fair
------------------------------------------------------------

- movfuscation blocks naive static analysis
- No plaintext flag in binary
- No string leaks
- No early-exit oracle
- Binary input required
- Multi-layer reversible transform
- Requires multiple tools and reasoning

------------------------------------------------------------
End of Write-Up
------------------------------------------------------------
