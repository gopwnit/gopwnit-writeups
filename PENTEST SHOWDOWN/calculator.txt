==================================================
        SYSTEM V CALCULATOR — DETAILED WRITE-UP
==================================================

Category : Reverse Engineering / Crypto / GUI
Difficulty: Medium

==================================================
1. CHALLENGE INTRODUCTION
==================================================

The challenge provides a Windows GUI binary named:

    System V Calculator – AUTH MODE

At first glance, the program looks like a normal
calculator. It contains numeric buttons, operators,
and an equals button.

However, pressing buttons does not perform any real
calculations. Instead, the program behaves like an
authentication gate.

The goal is to determine:
• The correct input
• The meaning of the output
• The final flag

==================================================
2. INITIAL GUI ANALYSIS (BLACK-BOX)
==================================================

The program only accepts input through buttons.
There is no command-line input or file interaction.

Observations from interacting with the GUI:

• Most numbers produce error-like messages
• Messages vary depending on the input
• Errors look like internal diagnostic messages
• Only one input produces a long hexadecimal output

Examples of messages:
• ACCESS DENIED
• PRIME CHECK FAILED
• CHECKSUM MISMATCH

This strongly suggests:
• Input validation logic
• Multiple validation layers
• Deterministic success condition

==================================================
3. INFERRING INPUT CONSTRAINTS (GUI METHOD)
==================================================

By testing inputs manually:

• Small numbers fail
• Even numbers fail
• Random large numbers fail
• Only one number succeeds

Some error messages explicitly mention:
• PRIME
• CHECKSUM

This suggests:
• The input must be a prime number
• The input must satisfy a checksum
• The input must be in a specific range

Testing common CTF primes in higher ranges leads to:

    31337

Entering:
    3 → 1 → 3 → 3 → 7 → =

produces a unique result instead of an error.

==================================================
4. INTERMEDIATE OUTPUT
==================================================

The program outputs:

    57cf81796ac0817252dc816b45cb9f6b5fcf8f7d5ac68443

Important observations:

• Hexadecimal characters only
• Even length
• Consistent output for the same input
• Generated dynamically

This confirms that the value is:
• Not random
• Not hardcoded
• Used as an intermediate stage

==================================================
5. REVERSE ENGINEERING THE VALIDATION LOGIC
==================================================

Static or dynamic analysis reveals the following
validation sequence:

--------------------------------------------------
5.1 PRIME CHECK
--------------------------------------------------

The program tests if the input is prime:

    if (!is_prime(n)) fail;

--------------------------------------------------
5.2 RANGE CHECK
--------------------------------------------------

The input must be between 30000 and 40000:

    if (!(n > 30000 && n < 40000)) fail;

--------------------------------------------------
5.3 CHECKSUM CHECK
--------------------------------------------------

A custom checksum is computed:

    stage1 = ((n << 3) | (n >> 2)) & 0xFFFF;
    stage2 = stage1 ^ 0x5A3C;
    stage3 = (stage2 * 1337) % 65521;

The result must equal:

    30507

--------------------------------------------------
5.4 CHECKSUM SOLUTION
--------------------------------------------------

Brute-forcing prime numbers in the allowed range
against the checksum reveals:

    n = 31337

This is the only value that passes all checks.

==================================================
6. REVERSE ENGINEERING THE OUTPUT GENERATION
==================================================

After validation, a generator routine is called.

Observed behavior:

• Output length: 24 bytes
• Rolling key
• Seed-derived bytes
• XOR-based mixing

Equivalent pseudocode:

    key = seed & 0xFF
    for i in range(24):
        key = (key + i * 7) & 0xFF
        byte = key ^ ((seed >> ((i % 4) * 8)) & 0xFF)
        output.append(byte)

For seed = 31337, this produces the observed hex
string.

==================================================
7. IDENTIFYING THE CRYPTOGRAPHY
==================================================

The output:

    57cf81796ac0817252dc816b45cb9f6b5fcf8f7d5ac68443

is NOT:
• MD5
• SHA-1
• SHA-256
• Base64

Why:
• Depends on input seed
• Reversible
• No fixed hash structure

Conclusion:
• This is XOR encryption

==================================================
8. XOR ANALYSIS
==================================================

XOR properties:

    ciphertext = plaintext XOR key
    plaintext  = ciphertext XOR key

Key hint provided:

    xx 83 c0 xx

This implies:
• Repeating 4-byte XOR key
• Two bytes known
• Two bytes unknown

Key structure:

    [k0, 0x83, 0xC0, k3]

==================================================
9. BRUTE-FORCING THE XOR KEY
==================================================

Unknown key space:

    256 × 256 = 65,536 possibilities

This is trivial to brute-force.

Strategy:
• Convert hex to bytes
• XOR-decrypt with all possible keys
• Keep printable ASCII results
• Filter for flag-like patterns

==================================================
10. BRUTE-FORCE SCRIPT
==================================================

Python script used:

    import string

    cipher_hex = "57cf81796ac0817252dc816b45cb9f6b5fcf8f7d5ac68443"
    cipher = bytes.fromhex(cipher_hex)

    PRINTABLE = set(bytes(string.printable, "ascii"))

    def is_printable(bs):
        return all(b in PRINTABLE for b in bs)

    for k0 in range(256):
        for k3 in range(256):
            key = bytes([k0, 0x83, 0xC0, k3])
            plaintext = bytes(
                cipher[i] ^ key[i % 4]
                for i in range(len(cipher))
            )

            if not is_printable(plaintext):
                continue

            text = plaintext.decode(errors="ignore")

            if "{" in text and "}" in text:
                print(f"KEY: {key.hex()} -> {text}")

==================================================
11. IDENTIFYING THE CORRECT FLAG
==================================================

Among many candidates, only one result is fully
valid:

    KEY: 11 83 c0 3e
    TEXT: FLAG{CALC_AUTH_UNLOCKED}

Why this is correct:

• Proper FLAG{...} format
• Fully readable ASCII
• Meaningful message
• No corrupted characters
• Unique best candidate

==================================================
12. FINAL RESULTS
==================================================

Correct Input:
    31337

XOR Key (hex):
    11 83 c0 3e

Final Flag:
    FLAG{CALC_AUTH_UNLOCKED}

==================================================
13. CONCLUSION
==================================================

This challenge demonstrates:

• GUI-based reasoning
• Layered validation logic
• Runtime-generated secrets
• XOR cryptanalysis with partial keys
• Constrained brute-force techniques

The solution is achieved through methodical
analysis, not guessing.

==================================================
END OF FILE
==================================================
