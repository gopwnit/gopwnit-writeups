===========================================
REVERSE ENGINEERING WRITE-UP (BEGINNER)
Challenge Name: Table Hell
===========================================

-------------------------------------------
1. WHAT WE ARE GIVEN
-------------------------------------------

We are given a single file:

    chall

There is:
- No source code
- No hints
- No readme
- No symbols
- No debug output

Our only goal is simple:

    Make the program print: "Correct"

-------------------------------------------
2. FIRST CONTACT (DO NOT SKIP)
-------------------------------------------

Open a terminal and run:

    ./chall

The program waits for input.

Try something simple:

    echo test | ./chall

Output:

    Wrong

This tells us:
- The program expects input
- It checks correctness
- It does NOT crash

-------------------------------------------
3. IDENTIFY THE FILE TYPE
-------------------------------------------

Run:

    file chall

Example output:

    ELF 64-bit LSB executable, x86-64, stripped

What this means (IMPORTANT FOR BEGINNERS):

- ELF → Linux binary
- 64-bit → modern system
- stripped → function names removed
- We MUST reverse engineer

-------------------------------------------
4. STRINGS CHECK (ALWAYS DO THIS)
-------------------------------------------

Run:

    strings chall

You should see something like:

    Correct
    Wrong

And not much else.

This tells us:
- The flag is NOT stored as text
- The program calculates correctness

-------------------------------------------
5. TEST INPUT LENGTH (VERY IMPORTANT)
-------------------------------------------

Try short input:

    echo A | ./chall

Try long input:

    echo AAAAAAAAAAAAAAAAAAAAA | ./chall

Still prints:

    Wrong

Now try a fixed-length input:

    python3 - << EOF
    print("A"*43)
    EOF | ./chall

Still "Wrong".

IMPORTANT CONCLUSION:

- The program expects EXACT length
- Likely checks EACH BYTE

-------------------------------------------
6. OPEN THE BINARY IN GHIDRA / IDA
-------------------------------------------

We now use a disassembler.

Recommended for beginners:
- GHIDRA (free)
- IDA Free also works

Steps in Ghidra:
1. Open Ghidra
2. New Project
3. Import "chall"
4. Let analysis finish
5. Open Decompiler window

-------------------------------------------
7. FIND THE MAIN FUNCTION
-------------------------------------------

Look for a function that:
- Calls fgets
- Calls strlen
- Calls puts

Rename it to:

    main

Inside main you will see logic similar to:

    read input
    check length
    call verify()
    print Correct or Wrong

-------------------------------------------
8. FIND THE VERIFY FUNCTION
-------------------------------------------

The verify function:
- Is called once
- Takes the input buffer
- Returns 0 or 1

Rename this function to:

    verify

-------------------------------------------
9. UNDERSTAND VERIFY (DO NOT PANIC)
-------------------------------------------

Inside verify, you will see:

- A loop
- Loop index usually called i
- Access to input[i]
- MANY table lookups
- A comparison against an array

Typical pattern:

    for each byte:
        x = input[i]
        x = table[x]
        x = table[x]
        ...
        if x != magic[i]:
            return 0

This is VERY IMPORTANT.

-------------------------------------------
10. KEY IDEA (BEGINNER FRIENDLY)
-------------------------------------------

This program does NOT use:
- Cryptography
- Hashing
- Math equations

It uses:
- TABLE LOOKUPS

The logic is hidden inside DATA.

This technique is called:
    "Table-based obfuscation"

-------------------------------------------
11. WHAT ARE THESE TABLES?
-------------------------------------------

Tables are:
- Large arrays (often size 256)
- Full of random-looking numbers
- Used like: table[x]

They replace logic like:
- if/else
- formulas
- math

-------------------------------------------
12. VERY IMPORTANT REALIZATION
-------------------------------------------

You DO NOT need to understand:
- Why tables exist
- How tables were generated
- What math they represent

You ONLY need to:
    Copy what the program does

This is called:
    Emulation

-------------------------------------------
13. IDENTIFY ALL TABLES
-------------------------------------------

In Ghidra:
- Look in .rodata
- Look for arrays of 256 bytes
- Rename them as you see them

You will find:
- Many tables used for lookup
- One array called "magic"

The "magic" array:
- Has the SAME length as the flag
- Stores the final expected value

-------------------------------------------
14. TABLE MUTATION (IMPORTANT DETAIL)
-------------------------------------------

One table changes during execution:

    T4[x] ^= something

This means:
- The table changes every iteration
- Dumping tables ONCE is not enough
- But changes are DETERMINISTIC

This is NOT randomness.
This is SAFE to emulate.

-------------------------------------------
15. WHY BYTE-BY-BYTE SOLVING WORKS
-------------------------------------------

Each flag byte:
- Is processed independently
- Only depends on its index
- Can be brute-forced

There are only:
    256 possibilities per byte

-------------------------------------------
16. WRITE A PYTHON EMULATOR
-------------------------------------------

We now copy the logic into Python.

Pseudo-code:

    for each index i:
        for each possible byte b (0..255):
            run the same table pipeline
            if result == magic[i]:
                flag[i] = b

-------------------------------------------
17. WHY THIS IS EASY FOR COMPUTERS
-------------------------------------------

Total work:
    43 bytes * 256 tries = ~11000 operations

This is trivial.

-------------------------------------------
18. RUN THE SOLVER
-------------------------------------------

After implementing the pipeline correctly,
the solver prints the flag.

-------------------------------------------
19. FINAL FLAG
-------------------------------------------

The recovered flag is:

    flag{tables_do_not_lie_but_they_do_not_speak}

-------------------------------------------
20. WHAT THIS CHALLENGE TEACHES
-------------------------------------------

BEGINNER TAKEAWAYS:

- Reverse engineering is not always math
- Data can hide logic
- Tables are common in malware
- Emulation is more powerful than guessing
- If code looks scary, copy behavior

-------------------------------------------
21. FINAL WORDS
-------------------------------------------

This challenge looks hard,
but is designed to teach:

    "Understand behavior, not intent"

If you solved this, you are no longer a beginner.

===========================================
END OF WRITE-UP
===========================================
