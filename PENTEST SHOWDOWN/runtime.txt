====================================================================
OFFICIAL WRITEUP
Challenge Name : Runtime Specter
Category       : Reverse Engineering
Difficulty     : Medium
File Provided  : challenge.exe
Platform       : Windows x64
====================================================================


========================
[0] CHALLENGE OVERVIEW
========================

We are given a single Windows executable named `challenge.exe`.

No source code is provided.
No symbols are present.
No additional files are included.

The goal is to determine the correct flag that makes the program
print:

    ✅ ACCESS GRANTED

The challenge description hints that static analysis alone
will not be sufficient.


========================
[1] INITIAL EXECUTION
========================

Running the executable normally:

    === Secure Runtime Validator v4.2 ===
    Enter flag:

Testing random inputs:

    test
    ❌ ACCESS DENIED

Trying longer inputs, correct format guesses, etc., always results in:

    ❌ ACCESS DENIED

Now we attempt to run the program under a debugger (x64dbg).


========================
[2] DEBUGGER DETECTION
========================

When running under x64dbg:

    ❌ Unstable environment detected

The program exits immediately.

This strongly indicates the presence of **anti-debugging logic**.


========================
[3] STATIC ANALYSIS – ANTI-DEBUGGING
========================

Opening the binary in IDA or Ghidra reveals:

- Imports from KERNEL32.DLL
- Calls to:
  - IsDebuggerPresent
  - CheckRemoteDebuggerPresent
- Use of RDTSC (timestamp counter)

These checks are used to detect debugging via:
- Debug flags in the PEB
- Debugger attachment
- Abnormal execution timing

Importantly:
The program does NOT crash.
It **changes program logic** when a debugger is detected.


========================
[4] BYPASSING ANTI-DEBUGGING
========================

Several valid bypass methods exist (any is acceptable):

Method A:
- Patch IsDebuggerPresent to always return 0

Method B:
- Patch conditional jumps after debugger checks

Method C:
- Run without debugger, attach later (not ideal)

After patching the debugger checks,
the program runs normally under x64dbg.


========================
[5] HIGH-LEVEL RUNTIME FLOW
========================

Stepping through execution reveals the following sequence:

1. User input (flag) is read
2. A 32-bit value is derived from the input
3. A "fake" check may modify that value
4. An encrypted byte array is decrypted
5. Memory is allocated with execute permissions
6. The decrypted bytes are copied into memory
7. The memory is called as a function
8. The return value is combined with the derived key
9. A final comparison determines success or failure

This confirms:

>>> The real validation logic is executed ONLY at runtime <<<


========================
[6] IDENTIFYING DYNAMIC CODE EXECUTION
========================

The following instruction pattern is observed:

- VirtualAlloc with PAGE_EXECUTE_READWRITE
- memcpy into allocated memory
- Indirect function call via function pointer

This is a classic **runtime code generation** technique.

Static analysis will NEVER show:
- The real validation logic
- The flag check algorithm
- Any useful comparison strings


========================
[7] KEY DERIVATION ANALYSIS
========================

Before the runtime code executes, the program computes a key.

Observations:
- The key depends on the ENTIRE input string
- Each character and its position influence the key
- Bit rotations and multiplications are used

Additionally:
- A fake validation path may XOR the key with a constant
- This path is intentionally misleading

Conclusion:
The final comparison depends on BOTH:
- Runtime-generated code
- Input-derived key


========================
[8] DUMPING THE RUNTIME CODE
========================

To extract the hidden logic:

1. Set a breakpoint immediately AFTER the decryption loop
2. Set another breakpoint BEFORE the function call
3. Identify the allocated executable memory region
4. Dump that memory region to a file

Tools that can be used:
- x64dbg memory dump
- Scylla
- Process Hacker

The dumped data is raw machine code.


========================
[9] REVERSE ENGINEERING THE DUMPED CODE
========================

Load the dumped binary into:
- IDA (as raw x64 code)
- Ghidra (manual import)

After cleanup, the following behavior is reconstructed:

- The function checks flag length
- Uses a rolling 32-bit state variable
- For each character:
  - Mixes character value and position
  - Performs bit rotation
  - Adds a constant
- Returns a 32-bit integer

There is:
- No hardcoded flag
- No string comparison
- No lookup table


========================
[10] FINAL VALIDATION CONDITION
========================

Back in the main binary, the final check is:

    (runtime_result XOR derived_key) == 0xCAFEBABE

This means:
- Dumping runtime code alone is insufficient
- Key derivation must also be reversed
- Both computations must align


========================
[11] SOLVING THE FLAG
========================

To solve the challenge:

1. Reimplement the key derivation function
2. Reimplement the runtime validation logic
3. Enforce the correct flag length
4. Solve the equation:

    validate(flag) ^ derive_key(flag) == 0xCAFEBABE

Because:
- The algorithm is deterministic
- State updates are sequential

The flag can be solved character-by-character
using controlled brute-force over printable characters.


========================
[12] FINAL FLAG
========================

After reconstructing both algorithms and solving the constraint,
the correct flag is:

    FLAG{RUNTIME_CODE_IS_EVIL}

Entering this flag produces:

    ✅ ACCESS GRANTED


========================
[13] WHY THIS IS MEDIUM DIFFICULTY
========================

The challenge is NOT trivial because:
- Static analysis alone fails
- Runtime code must be dumped
- Anti-debugging must be bypassed
- Multi-stage logic exists

The challenge is NOT hard because:
- No virtualization
- No heavy obfuscation
- No cryptographic primitives
- Runtime code is dumpable
- Logic is reversible


========================
[14] FINAL NOTES
========================

This challenge intentionally teaches:

- Why dynamic analysis matters
- How runtime code hides logic
- Why dumping memory is valid
- How anti-debugging affects execution
- Why guessing flags does not work

====================================================================
END OF WRITEUP
====================================================================
